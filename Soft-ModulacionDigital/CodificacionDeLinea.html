<html lang="en" class="">

<head>

  <meta charset="UTF-8">
  <title>CodePen Demo</title>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

  <meta name="robots" content="noindex">

  <style class="INLINE_PEN_STYLESHEET_ID">
    canvas {
      display: block;
      margin: auto auto;
      background: #f0f0f0;
      border: 1px solid #fb0;
    }
  </style>


</head>

<body onload="drawPlanCartesiano();" style="color:#808080; background:#696969">

  
  <label>ingresar cadena</label>
  <input id="idCadena" value="01001110">
  <select name="nVoltaje" id="idVoltaje">
    <option value="1">Positivo</option>
    <option value="-1">Negativo</option>
  </select>
  <button onclick="ObtenerUniPolarNRZ();"> Unipolar NRZ</button>
  <button onclick="ObtenerPolarNRZ_L();"> Polar NRZ-L</button>
  <button onclick="ObtenerPolarNRZ_I();"> Polar NRZ-I</button>
  <button onclick="ObtenerPolarRZ();"> Polar RZ</button>
  <button onclick="ObtenerManchester();"> Manchester</button>
  <button onclick="ObtenerManchesterDiferencial();"> Manchester Diferencial (falta)</button>
  <button onclick="ObtenerAMI();"> AMI</button>
  <button onclick="ObtenerPseudoTernaria();"> Pseudo Ternaria</button>
  <button onclick="ObtenerB8ZS();"> B8ZS</button>
  <button onclick="ObtenerHDB3();"> HDB3</button>
  <canvas id="Cartesiano" width="1000" height="400"></canvas>
  <script id="">
    /* 
    Array de pontos cartesianos, cada item da array precisa ter
    coordenadas de X e Y, esses valores devem ser inseridos
    baseados no 1º Quadrante do Cartesiano (Igual usado em livros)
  */
    let pontosCartesianos = [];
    /*
      Aqui você seleciona quais pontosCartesianos serão conectadas,
      cada valor referencia diretamente o indice da coordenada 
      na Array pontosCartesianos.
    */

    //a-b     c-d
    let linesCartesianas = [];

    // Margem de espaçamento nas laterais para desenho do grafico
    let margin_spaces = 80;

    // Escala que determina o número de pontos que terá o plano cartesiano
    let escala = 10;

    // Sequencia de letras que será nomeadao os pontos
    let alfabeto = "abcdefghijklmnñopqrstuvwzxz";
    //a      b       c       d      e
    pontosCartesianos = [
    //[X, Y],
      [0, 0],
      [0, 2], //
      [1, 0],
      [1, 2],
      [2, 0],
      [2, 2],
      [3, 0],
      [3, 2], //
      [4, 0],
      [4, 2],
      [5, 0],
      [5, 2],
      [6, 0],
      [6, 2],
      [7, 0],
      [7, 2],
      [8, 0],
      [8, 2],
      [9, 0],
      [9, 2],
      [10, 0],
      [10, 2],
    ];

    linesCartesianas = [
      [0, 1]
    ];

    let canvas = document.getElementById('Cartesiano');
    let context = canvas.getContext('2d');

    let ancho = 300;
    let alto = 300;

    // cálcula a escala para ter um espaçamento em seu limite
    escala = Math.ceil(escala * 1.2);
    // cálcula o tamanho em pixels de cada unidade para cada coordenada da escala determinada.
    let step_size = [Math.floor((margin_spaces * 2 + ancho) / escala), Math.floor((margin_spaces * 2 + canvas
      .height) / escala)];
      
    // ponto em pixels do ponto zero do 1º Quadrante
    let ponto_zero = [margin_spaces, alto - margin_spaces];

    // Converte a coordenada do 1º Quadrante para 4º Quadrante (Pixels) 
    const converte_primeiro_para_quarto = coordenada => [ponto_zero[0] + coordenada[0] * step_size[0], ponto_zero[1] +
      coordenada[1] * step_size[1] * -1
    ];
    /*
    Função que desenha todos os componentes de um ponto no plano cartesiano
    */
    function drawnPoint(coordenada, index) {
      // Converte a coordenada do 1º Quadrante para 4º Quadrante (Pixels) 
      let coordenada_normalizada = converte_primeiro_para_quarto(coordenada);

      context.beginPath();
      context.moveTo(coordenada_normalizada[0], coordenada_normalizada[1]);
      // cria o ponto
      context.arc(coordenada_normalizada[0], coordenada_normalizada[1], 3, 0, Math.PI * 2, true);
      context.fill();

      // cria o texto
      context.font = 'italic 18px roboto';
      context.fillText(alfabeto[index], coordenada_normalizada[0] - margin_spaces * 1.4, coordenada_normalizada[1] -
        margin_spaces * 0.2);
      context.closePath();

      // cria linha pontilhada horizontal
      context.beginPath();
      context.setLineDash([5, 5]);
      context.moveTo(coordenada_normalizada[0], coordenada_normalizada[1]);
      context.lineTo(margin_spaces, coordenada_normalizada[1]);
      context.stroke();
      context.closePath();

      // cria linha pontilhada vertical
      context.beginPath();
      context.moveTo(coordenada_normalizada[0], coordenada_normalizada[1]);
      context.lineTo(coordenada_normalizada[0], alto - margin_spaces);
      context.stroke();
      context.closePath();

      // cria os textos nas absissas e nas ordenadas
      context.font = '14px serif';
      //context.strokeStyle = '#ff0000';
      context.fillText('', coordenada_normalizada[0] - margin_spaces * 0.3, alto - margin_spaces * 0.3);
      context.fillText('', margin_spaces * 0.3, coordenada_normalizada[1]);
    }

    // Cria as linhas no plano apartr das coordenas cartesianas
    function drawnLines(coordenadas, lines) {
      context.strokeStyle = '#ff0000';
      let coordenada_convertidas = coordenadas;

      //percorre as regras das linhas
      lines.forEach(line => {
        /* 
          Para cada coordenada em que a linha referencia, 
          antes de deter a coordenada do quadrante, é somado um valor de direção
          primeira ponto da linha diminui e o segundo um maior
        */
        coordenada_convertidas = coordenada_convertidas.map(
          (coordenada, index) => {
            let direction = 0;
            return converte_primeiro_para_quarto([coordenada[0] + direction, coordenada[1] + direction]);
          });

        context.beginPath();
        context.lineWidth = 2;
        context.setLineDash([0, 0]);
        context.moveTo(coordenada_convertidas[line[0]][0], coordenada_convertidas[line[0]][1]);
        context.lineTo(coordenada_convertidas[line[1]][0], coordenada_convertidas[line[1]][1]);
        context.stroke();
        context.closePath();
      });
    }
    /*
    function angle(cx, cy, ex, ey) {
      var dy = ey - cy;
      var dx = ex - cx;
      var theta = Math.atan2(dy, dx); // range (-PI, PI]
      theta *= 180 / Math.PI; // rads to degs, range (-180, 180]
      //if (theta < 0) theta = 360 + theta; // range [0, 360)
      return theta;
    }
    */
    function drawPlanCartesiano() {
      console.log("entranding");

      // Flecha triângulo ^
      context.beginPath();
      context.moveTo(margin_spaces - 5, margin_spaces);
      context.lineTo(margin_spaces + 5, margin_spaces);
      context.lineTo(margin_spaces, margin_spaces - 5);
      context.fill();

      // cria a linha vertical
      context.moveTo(margin_spaces, margin_spaces);
      context.lineTo(margin_spaces, alto + 100- margin_spaces / 2);

      // cria a linha horizontal  
      context.moveTo(margin_spaces / 2, alto - margin_spaces);
      context.lineTo(ancho * 3.5 - margin_spaces, alto - margin_spaces);
      context.stroke();

      // cria flecha triangular >
      context.moveTo(ancho * 3.5 - margin_spaces, alto - margin_spaces - 5);
      context.lineTo(ancho * 3.5 - margin_spaces, alto - margin_spaces + 5);
      context.lineTo(ancho * 3.5 - margin_spaces + 6, alto - margin_spaces);
      context.fill();
      context.closePath();

      /*
          //ponto circular no ponto zero
          context.moveTo(margin_spaces,alto-margin_spaces);
          context.beginPath();
          context.arc(margin_spaces,alto-margin_spaces, 2, 0, Math.PI * 2, true);
          context.fill();
          context.closePath();
      */

      // Percorre a configuração dos pontos cartesianos mandando para função drawnPoint
      /*
      pontosCartesianos.forEach((point, index) => {
        console.log(point, index);
        drawnPoint(point, index);
      });
      */

      drawnPoint([20, 2], 21);
      drawnPoint([20, -2], 21);
      // dropa as linhas
      //drawnLines(pontosCartesianos, linesCartesianas);
    }



    /* METODOS */
    /* METODOS */
    /* METODOS */
    /* METODOS */


    var ObtenerUniPolarNRZ = function () {
      LimpiarCanvas();
      pontosCartesianos = [];
      var divisiones = $("#idCadena").val().split("");

      divisiones.forEach((point, index) => {
        if(point == 1) {
          pontosCartesianos.push([index * 2 , 2]);
          pontosCartesianos.push([index * 2 + 2 , 2]);
        }
        else {
          pontosCartesianos.push([index * 2 , 0]);
          pontosCartesianos.push([index * 2 + 2 , 0]);
        }
      });
      console.log(pontosCartesianos);
      pontosCartesianos.forEach((point, index) => {
        linesCartesianas = [
            [index, index + 1]
          ];
          drawnLines(pontosCartesianos, linesCartesianas);
      });
    };

    var ObtenerPolarNRZ_L = function () {
      LimpiarCanvas();
      pontosCartesianos = [];
      var divisiones = $("#idCadena").val().split("");
      divisiones.forEach((point, index) => {
        if(point == 1) {
          pontosCartesianos.push([index * 2 , -1]);
          pontosCartesianos.push([index * 2 + 2 , -1]);
        }
        else {
          pontosCartesianos.push([index * 2 , 1]);
          pontosCartesianos.push([index * 2 + 2 , 1]);
        }
      });
      pontosCartesianos.forEach((point, index) => {
        linesCartesianas = [
            [index, index + 1]
          ];
          drawnLines(pontosCartesianos, linesCartesianas);
      });
    };

    var ObtenerPolarNRZ_I = function () {
      LimpiarCanvas();
      voltaje = $("#idVoltaje").val();
      pontosCartesianos = [];

      if (voltaje == 1)
      {
        pontosCartesianos.push([0 , 1]);
      }
      else
      {
        pontosCartesianos.push([0 , -1]);
      }

      var divisiones = $("#idCadena").val().split("");

      divisiones.forEach((point, index) => {
        
        if(voltaje == 1 && point == 1) {
          console.log("voltaje == 1 && point == 1");
          voltaje = -1;
          pontosCartesianos.push([index * 2 , -1]);
          pontosCartesianos.push([index * 2 + 2 , -1]);
        }
        else
        {
          if(voltaje == -1 && point == 1) {
            console.log("voltaje == -1 && point == 1");
            voltaje = 1;
            pontosCartesianos.push([index * 2 , 1]);
            pontosCartesianos.push([index * 2 + 2 , 1]);
          }
          else {
            console.log("cerooo");
            //pontosCartesianos.push([index * 2 , 1 * voltaje]);
            pontosCartesianos.push([index * 2 + 2 , 1 * voltaje]);
          }
        }
      });
      console.log(pontosCartesianos);

      pontosCartesianos.forEach((point, index) => {
        linesCartesianas = [
            [index, index + 1]
          ];
          drawnLines(pontosCartesianos, linesCartesianas);
      });
    };

    var ObtenerPolarRZ = function () {
      LimpiarCanvas();
      pontosCartesianos = [];
      var divisiones = $("#idCadena").val().split("");

      divisiones.forEach((point, index) => {
        if(point == 1) {
          pontosCartesianos.push([index * 2 , 1]);
          pontosCartesianos.push([index * 2 + 1 , 1]);
          pontosCartesianos.push([index * 2 + 1 , 0]);
          pontosCartesianos.push([index * 2 + 2 , 0]);
        }
        else {
          pontosCartesianos.push([index * 2 , -1]);
          pontosCartesianos.push([index * 2 + 1 , -1]);
          pontosCartesianos.push([index * 2 + 1 , 0]);
          pontosCartesianos.push([index * 2 + 2 , 0]);
        }
      });
      console.log(pontosCartesianos);
      pontosCartesianos.forEach((point, index) => {
        linesCartesianas = [
            [index, index + 1]
          ];
          drawnLines(pontosCartesianos, linesCartesianas);
      });
    };

    var ObtenerManchester = function () {
      LimpiarCanvas();
      pontosCartesianos = [];
      var divisiones = $("#idCadena").val().split("");

      divisiones.forEach((point, index) => {
        if(point == 1) {
          pontosCartesianos.push([index * 2 , -2]);
          pontosCartesianos.push([index * 2 + 1 , -2]);
          pontosCartesianos.push([index * 2 + 1 , 2]);
          pontosCartesianos.push([index * 2 + 2 , 2]);
        }
        else {
          pontosCartesianos.push([index * 2 , 2]);
          pontosCartesianos.push([index * 2 + 1 , 2]);
          pontosCartesianos.push([index * 2 + 1 , -2]);
          pontosCartesianos.push([index * 2 + 2 , -2]);
        }
      });
      console.log(pontosCartesianos);
      pontosCartesianos.forEach((point, index) => {
        linesCartesianas = [
            [index, index + 1]
          ];
          drawnLines(pontosCartesianos, linesCartesianas);
      });
    };


    var ObtenerManchesterDiferencial = function () {
      LimpiarCanvas();
      pontosCartesianos = [];

      voltaje = $("#idVoltaje").val();
      if (voltaje == 1)
        pontosCartesianos.push([0 , 2]);
      else
        pontosCartesianos.push([0 , -2]);

      var divisiones = $("#idCadena").val().split("");
      
      divisiones.forEach((point, index) => {
        if(point == 1) {
          
          pontosCartesianos.push([index * 2 , 2 * voltaje]);
          pontosCartesianos.push([index * 2 + 1 , 2 * voltaje]);
          pontosCartesianos.push([index * 2 + 1 , -2 * voltaje]);
          pontosCartesianos.push([index * 2 + 2 , -2 * voltaje]);
          voltaje = voltaje*-1;
        }
        else {
          pontosCartesianos.push([index * 2 , - 2 * voltaje]);
          pontosCartesianos.push([index * 2 + 1 , -2 * voltaje]);
          pontosCartesianos.push([index * 2 + 1 , 2 * voltaje]);
          pontosCartesianos.push([index * 2 + 2 , 2 * voltaje]);
        }
      });
      console.log(pontosCartesianos);
      pontosCartesianos.forEach((point, index) => {
        linesCartesianas = [
            [index, index + 1]
          ];
          drawnLines(pontosCartesianos, linesCartesianas);
      });
    };

    var ObtenerAMI = function (voltaje) { 
      LimpiarCanvas();
      voltaje = $("#idVoltaje").val();
      voltaje = voltaje * (-1);
      
      pontosCartesianos = [];
      var divisiones = $("#idCadena").val().split("");

      divisiones.forEach((point, index) => {
        if(point == 1) {
          pontosCartesianos.push([index * 2 , 2 * voltaje]);
          pontosCartesianos.push([index * 2 + 2 , 2 * voltaje]);
          voltaje = voltaje * (-1);
        }
        else {
          pontosCartesianos.push([index * 2 , 0]);
          pontosCartesianos.push([index * 2 + 2 , 0]);
        }
      });
      console.log(pontosCartesianos);
      pontosCartesianos.forEach((point, index) => {
        linesCartesianas = [
            [index, index + 1]
          ];
          drawnLines(pontosCartesianos, linesCartesianas);
      });
    };

    var ObtenerPseudoTernaria = function () { 
      LimpiarCanvas();

      voltaje = $("#idVoltaje").val();
      
      pontosCartesianos = [];
      pontosCartesianos.push([0 , 0]);

      var divisiones = $("#idCadena").val().split("");

      divisiones.forEach((point, index) => {
        if(point == 1) {
          pontosCartesianos.push([index * 2 , 0]);
          pontosCartesianos.push([index * 2 + 2 , 0]);
        }
        else {
          pontosCartesianos.push([index * 2 , 2 * voltaje]);
          pontosCartesianos.push([index * 2 + 2 , 2 * voltaje]);
          voltaje = voltaje * -1;
        }
      });
      console.log(pontosCartesianos);
      pontosCartesianos.forEach((point, index) => {
        linesCartesianas = [
            [index, index + 1]
          ];
          drawnLines(pontosCartesianos, linesCartesianas);
      });
    };

    var LimpiarCanvas = function()
    {
      canvas.width=canvas.width;
      console.log("limpiando");
      //$("#Cartesiano").html("");
      drawPlanCartesiano();
    }

//ObtenerPseudoTernaria
  </script>


</body>

</html>